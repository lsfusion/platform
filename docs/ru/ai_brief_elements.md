## Бриф по элементам lsFusion для ИИ‑агентов

Формат: **очень кратко**, для понимания и генерации кода. Более подробная информация ищется через RAG в документации.

---

## Основные элементы (от более к базовым к более сложным)

### Классы

- **Аналогия**: классы в ООП, плюс множественный полиморфизм по нескольким параметрам. Задают тип объектов и используются в сигнатурах свойств/действий/форм.
- **Описание**: базовый элемент — множество объектов. Могут наследоваться. Делятся на примитивные (встроенные: `INTEGER`, `LONG`, `NUMERIC[p,s]`, `STRING[n]`, `ISTRING[n]`, `BOOLEAN`, `DATE`, `TIME`, `DATETIME`, `FILE`, `IMAGEFILE` и др.) и пользовательские. Полиморфизм реализуется через наследование, `ABSTRACT` свойства/действия + `+=` / `ACTION+`, `MULTI`.
- **Синтаксис (поиск)**: `CLASS ClassName ['Caption'] [: ParentClass];`

### Свойства

- **Аналогия**: функции в математике / «чистые функции» в программировании. Вычисляют факты над объектами, не изменяют состояние. Декларативная часть, ближе к SQL.
- **Описание**: делятся на DATA‑свойства (хранимые, соответствуют полям таблиц БД) и вычисляемые (формулы, агрегаты, композиции других свойств).
- **Синтаксис (поиск)**: `name 'Caption' = DATA Type (Class1, ...);` или `name (Params...) = Expression;`

### Действия

- **Аналогия**: процедуры / методы в других языках программирования. Меняют состояние системы (в БД или внешних системах). Императивная часть, ближе к Java/процедурному коду.
- **Описание**: дуализм со свойствами: свойства — вычисление/чтение, декларативный, «что такое система»; действия — изменение/процесс, императивный, «как система эволюционирует».
- **Синтаксис (поиск)**: `actionName 'Caption' (Params...) { ActionOperators }`

### Формы

- **Аналогия**: запросы в SQL, но в существенно общем случае, когда получается много таблиц сразу. Универсальный элемент работы с наборами данных и UI.
- **Описание**: структура формы содержит `OBJECTS` (группы объектов — списки, деревья), `PROPERTIES` (что показывать / какие действия доступны), `FILTERS` (отбор строк на уровне формы). Форма может отображаться в разных представлениях: интерактивном (`SHOW`), печатном (`PRINT`), структурном (`EXPORT`/`IMPORT`). Может расширяться через `EXTEND FORM`.
- **Синтаксис (поиск)**: `FORM FormName 'Caption' OBJECTS ... PROPERTIES ... FILTERS ... ;`

### События

- **Аналогия**: триггеры в СУБД, но в гораздо более общем случае. Связывают изменения данных с реакциями (действиями или изменениями свойств). Зависимы от времени (в отличие от ограничений, которые независимы от времени). Императивные процессы «если произошло что-то, сделать то-то».
- **Описание**: основной оператор — `WHEN` (простые предметные события изменения данных). Операторы анализа сессии изменений: `CHANGED`, `SET`, `DROPPED`, `SETCHANGED`, `DROPCHANGED`, `SETDROPPED`, `PREV`. События формы (UI‑события): `ON CHANGE`, `ON EDIT`, `ON CONTEXTMENU`, `ON GROUPCHANGE`, `ON CHANGEWYS` в `PROPERTIES` на форме. Блочные события: `BEFORE`, `AFTER` для действий.
- **Синтаксис (поиск)**: `prop(...) <- Expr WHEN CHANGED(...);` или `PROPERTIES(...) prop ON CHANGE action(...);`

### Ограничения

- **Аналогия**: ограничения целостности в СУБД, но для произвольных выражений и в любых контекстах. Логические инварианты, независимые от времени (в отличие от событий, которые зависимы от времени). Декларативные правила «что всегда должно быть верно».
- **Описание**: проверяются при попытке зафиксировать изменения (`APPLY`). При нарушении — ошибка (или авто‑исправление для простых ограничений). Виды: общие (`CONSTRAINT`), простые (`=>`, `NONULL`, уникальность через `GROUP AGGR`).
- **Синтаксис (поиск)**: `CONSTRAINT name 'Caption' CHECK condition(...);` или `premise(...) => consequence(...) [RESOLVE LEFT|RIGHT];`

### Агрегации

- **Аналогия**: агрегации в других языках, только они создаются декларативно (сами, независимо от времени) самой платформой. Механизм представления *объектов‑агрегатов*, связанных с базовыми данными.
- **Описание**: создаются через оператор `AGGR` (см. ниже в операторах свойств) + связанные ограничения. Платформа автоматически создает и поддерживает агрегирующие объекты по правилам, заданным в операторе `AGGR`. Используются для расширенного полиморфизма и правил целостности, когда «обобщающий объект» живет отдельно, но консистентен с базой.
- **Синтаксис (поиск)**: см. оператор `AGGR` в разделе «Операторы свойств».

### Дополнительные элементы

- **Навигатор (`NAVIGATOR`)**: структура меню / роутинг. Привязывают формы и действия к главному меню системы. По сути частный случай интерактивного представления формы.
- **Окна (`WINDOW`)**: раскладка нескольких форм / областей в одном UI‑окне.
- **Таблицы (`TABLE`)**: явные определения таблиц БД (обычно не нужны, платформа выводит автоматически). Используются при низкоуровневых IN / интеграциях.
- **Индексы (`INDEX`)**: явные индексы БД, обычно для оптимизации/интеграции. В большинстве случаев генерируются автоматически из свойств.

### Модули

- **Аналогия**: модуль / пакет / сборка. Функциональный блок логики (файл `.lsf`) с зависимостями.
- **Описание**: единица сборки и переиспользования. Содержат классы, свойства, действия, формы, события, ограничения и т.п. Задают зависимости через `REQUIRE`.
- **Синтаксис (поиск)**: `MODULE ModuleName;` `REQUIRE ModuleA, ModuleB;`

---

## Операторы свойств

### Базовые выражения

- **Описание**: арифметика (`+`, `-`, `*`, `/`, `(+), (-)` — NULL‑friendly), логика (`AND`, `OR`, `NOT`, `XOR`), строки (`+`, `CONCAT`, `SUBSTRING`), сравнения (`=`, `<`, `>`, `<=`, `>=`, `LIKE`), классификация (`IS`, `AS`), выбор (`IF ... THEN ... ELSE ...`, постфикс `f(a) IF g(a)`).
- **Синтаксис (поиск)**: стандартные операторы выражений.

### Композиция

- **Аналогия**: вызов функции внутри функции / композиция функций в математике. Использование одного свойства в выражении другого.
- **Описание**: свойство от свойства. Обычно задается неявно (простая подстановка свойств в выражение).
- **Синтаксис (поиск)**: использование свойств в выражениях других свойств.

### Группировка множеств (`GROUP`)

- **Описание**: оператор для агрегации *значений* (не путать с объектными агрегациями `AGGR`). Суммы, количество, максимум/минимум, последняя строка, строковая агрегация. Есть функциональная форма (с `IF`) и SQL‑подобная форма (с `BY`).
- **Синтаксис (поиск)**: `GROUP SUM|MAX|MIN|LAST|CONCAT source(...) IF Condition;` или `GROUP SUM|MAX|MIN|LAST|CONCAT source(...) BY groupExprs...;`

### Разбиение / оконные агрегаты (`PARTITION`)

- **Описание**: оператор для оконной логики: ранги, «предыдущее значение», кумулятивные суммы.
- **Синтаксис (поиск)**: `PARTITION AggOp expression IF Condition ORDER orderExprs...;`

### Агрегирующие объекты (`GROUP AGGR`)

- **Описание**: оператор, создающий/поддерживающий *агрегирующие объекты* (агрегации как элемент). Связывает базовые объекты и агрегатный объект через `BY`.
- **Синтаксис (поиск)**: `GROUP AGGR Class x WHERE BaseCondition BY groupExprs...;`

### Оператор `AGGR`

- **Описание**: оператор для создания агрегирующих объектов. Платформа автоматически создает/удаляет объекты агрегации при изменении базовых данных.
- **BNF**: `aggrPropertyDefinition ::= AGGR baseEventPE customClassUsage WHERE propertyExpression (NEW baseEventNotPE)? (DELETE baseEventNotPE)?`
- **Синтаксис (поиск)**: `AGGR Class x WHERE condition(...) [NEW newEvent] [DELETE deleteEvent] [MATERIALIZED] [INDEXED];`

### OVERRIDE

- **Описание**: склейка нескольких источников значения с приоритетом.
- **Синтаксис (поиск)**: `OVERRIDE expr1, expr2, expr3;`

### Рекурсия (`RECURSION`)

- **Описание**: рекурсивные свойства (деревья, графы, транзитивные замыкания). Аналогия: рекурсивные CTE в SQL (`WITH RECURSIVE`).
- **Синтаксис (поиск)**: `RECURSION baseExpr THEN stepExpr;`

### ABSTRACT

- **Описание**: объявление абстрактного свойства, реализации добавляются в других модулях через `+=`. Используется для полиморфизма, расширений, plug‑in логики.
- **Синтаксис (поиск)**: `ABSTRACT [MODIFIERS] Type (ParamClasses...);` и `prop[Context](Params...) += implExpr;`

---

## Операторы действий

### Базовые операторы

- **Изменения**: присваивание (`<-`), создание объектов (`NEW`), удаление (`DELETE`).
- **Вызов действия**: **Аналогия** — вызов функции / процедуры / метода. Просто указывается имя действия с параметрами. Не является изменением, выполняет другое действие.
- **Синтаксис (поиск)**: `property(...) <- Expression [WHERE Condition];`, `NEW alias = Class { ... }`, `DELETE ClassOrAlias obj WHERE Condition;`, `actionName(params...);`

### Последовательность

- **Описание**: блок действий, выполняемых по порядку.
- **Синтаксис (поиск)**: `actionName (Params...) { operator1; operator2; }`

### Цикл `FOR`

- **Описание**: обходит все наборы объектов, где условие‑свойство не `NULL`. Можно одновременно создавать объекты. Отличается от циклов в других языках.
- **Синтаксис (поиск)**: `FOR Expression [ORDER ...] [TOP n] [OFFSET m] [NEW alias = Class] DO { ... } [ELSE { ... }]`

### Рекурсивный цикл `WHILE`

- **Описание**: пока условие‑свойство где‑то истинно (не `NULL`), блок выполняется снова. Используется для сложных процедур, где «сходится» состояние.
- **Синтаксис (поиск)**: `WHILE condition DO { ... }`

### Ветвление

- **Описание**: `IF` — одиночное условие, `CASE` — несколько веток, `MULTI` + расширения — полиморфное ветвление по классам/подтипам.
- **Синтаксис (поиск)**: `IF condition THEN { ... } ELSE { ... }`, `CASE WHEN cond1 THEN { ... } WHEN cond2 THEN { ... }`, `MULTI impl1[p](p), impl2[p](p);`

### Управление потоком

- **Описание**: `BREAK`, `CONTINUE`, `RETURN`, `TRY ... CATCH ...`, `NEWTHREAD`, `NEWEXECUTOR` (асинхронные/параллельные действия).
- **Синтаксис (поиск)**: стандартные операторы управления потоком.

### Операторы работы с формой

- **Описание**: `SHOW`, `DIALOG` — открытие форм/диалогов, `SEEK` — смена текущего объекта в группе, `EXPAND`, `COLLAPSE` — раскрытие/сворачивание деревьев.
- **Синтаксис (поиск)**: `SHOW FormName [OBJECTS ...];`, `DIALOG FormName OBJECTS ... INPUT [FILTERS ...] DO { ... }`, `SEEK [FIRST|LAST] formGroup = obj;`

---

## Сессии изменений

- **Описание**: изолированный набор изменений в данных. По умолчанию: одна текущая сессия на действие / цепочку действий. До `APPLY` данные в БД не фиксируются, доступны только в текущей сессии. `APPLY` — попытка зафиксировать: при успехе изменения сохраняются, при нарушении ограничений `canceled() = TRUE`, `applyMessage()` содержит текст ошибки, данные остаются в сессии.
- **Операторы управления сессиями**: `NEWSESSION action` (новая независимая сессия), `NESTEDSESSION` (вложенная сессия, зависящая от внешней). Используются для «юнитов работы» (диалог, импорт, обработка одного файла и т.п.).

---

## Представления форм

### Интерактивное представление

- **Аналогия**: обычные формы/страницы других ИС, но единый поток выполнения (без разделения на «серверный» и «клиентский» язык).
- **Описание**: `SHOW` открывает форму в интерактивном режиме (окно/вкладка), платформа сама организует диалог и асинхронные обновления. `DIALOG` открывает форму как модальный диалог с возможностью выбора объекта (`INPUT`) или фильтрации (`FILTERS`). `DESIGN` задаёт визуальные детали (контейнеры, вкладки, панели, popup, деревья). `INPUT` — запрос значения у пользователя. Реактивность: изменение любых данных → автоматическое обновление всех зависимых представлений. WYSIWYG: изменения видны сразу.
- **Синтаксис (поиск)**: `SHOW formName [OBJECTS ...] [DOCKED];`, `DIALOG formName OBJECTS ... INPUT [FILTERS ...] DO { ... }`, `DESIGN formName { ... }`, `INPUT var = Type DO { ... }`

### Печатное представление

- **Аналогия**: системы отчётности (jrxml + JasperReports).
- **Описание**: формат jrxml описывает печатный вид; формирование отчёта инициируется из lsFusion. Для отображения в этом представлении нужно много дополнительной информации, задаваемой в jrxml‑файлах.
- **Синтаксис (поиск)**: `PRINT formName [OBJECTS ...] TO FILE fileVar;`

### Структурное представление

- **Аналогия**: структурированные форматы данных (JSON, XML, XLSX, DBF).
- **Описание**: `EXPORT` (действие) — сериализация данных формы/выражений в файл/поток. `JSON` (свойство) — генерация JSON‑структуры. `IMPORT` — загрузка данных обратно в форму/модель. В отличие от остальных представлений, структурное может использоваться в том числе для ввода/загрузки данных назад в форму.
- **Синтаксис (поиск)**: `EXPORT FROM expr1, expr2 TO fileVar;`, `prop(...) = JSON expr;`, `IMPORT JSON|CSV|XLS|XML FROM fileVar TO props...;`

---

## Интеграция

- **Общая идея**: та же парадигма (свойства/действия), но для общения с внешними и внутренними системами.

### Обращение из текущей системы во внешние (императивно, действия)

- **Описание**: `EXTERNAL` — вызовы HTTP / внешнего кода / внешних SQL‑функций как действий.
- **Синтаксис (поиск)**: `EXTERNAL Name 'id' [OPTIONS] (Params...);`

### Обращение из текущей системы во внешние (декларативно, свойства)

- **Описание**: `CUSTOM` — кастомные UI‑компоненты c JSON‑интерфейсом. `JSON` — формирование JSON‑структур для UI или API.
- **Синтаксис (поиск)**: `OBJECTS alias = Class CUSTOM 'componentName' ...`, `prop(...) = JSON expr;`

### Обращение из внешних систем в текущую

- **Описание**: Action API — вызов действий lsFusion из внешних систем через HTTP. Поддерживаются протоколы HTTP (порты `7651` для сервера приложений или веб‑сервера). Способы задания действия: `EXEC` (по имени), `EVAL` (код с действием `run`), `EVAL ACTION` (код действия). Form API — работа с формами через HTTP для фронтенд‑приложений. Действия помечаются `@@api` для доступа через API.
- **Синтаксис (поиск)**: `@@api` в опциях действия, URL: `/exec?action=...`, `/eval?script=...`, `/eval/action?script=...`

### Обращение из текущей системы во внутренние (императивно)

- **Описание**: `INTERNAL` — вызов Java‑кода из действий. На стороне Java: `findProperty`, `read`, `change` — доступ к логике lsFusion.
- **Синтаксис (поиск)**: `INTERNAL Name 'id' [OPTIONS] (Params...);`

### Обращение из текущей системы во внутренние (декларативно)

- **Описание**: `FORMULA` — свойства, вычисляемые SQL‑выражениями.
- **Синтаксис (поиск)**: `prop(...) = FORMULA 'sql expression with $1, $2, ...';`

---

## Физическая модель (структура БД)

- **Аналогия**: ручное/динамическое управление схемой БД (таблицы, индексы, материализация).
- **Описание**: основная цель — производительность и открытая структура БД.
- **Синтаксис (поиск)**: `TABLE tableName ['dbName'] (ClassOrParams...);`, `prop = DATA Type (Class) MATERIALIZED ['dbFieldName'] INDEXED ['indexName'];`

---

## Расширения

- **Описание**: механизм модульности и полиморфизма на уровне модулей. Позволяют наращивать функциональность без изменения исходных модулей. Виды: `EXTEND CLASS`, `EXTEND FORM`, `ABSTRACT` + `+=`, `ACTION+`.
- **Синтаксис (поиск)**: `EXTEND CLASS ClassName : ParentClass;`, `EXTEND FORM FormName ... ;`, `prop(...) += implExpr;`, `ACTION actionName(...) + { ... }`

---

## Метапрограммирование

- **Аналогия**: генераторы кода / шаблоны, но встроенные в язык.
- **Описание**: оператор `@` — метапрограммирование (генерация кода по описаниям). В IDE есть авто‑генерация кода.
- **Синтаксис (поиск)**: `@metaName { ... }`

---

## Идентификация элементов и эргономика языка

- **Пространства имён**: управление тем, какие имена видны по умолчанию. **Синтаксис (поиск)**: `NAMESPACE MyNamespace;`
- **Явная типизация**: параметры и локальные свойства всегда типизированы. **Синтаксис (поиск)**: `LOCAL var = Type ();`
- **Интерполяция строк**: возможность собирать строки из идентификаторов/значений (используется и в i18n). **Синтаксис (поиск)**: `'{namespace.element}'`

---

## Интернационализация

- **Описание**: локализация caption‑ов классов, свойств, форм и т.д. через resource‑bundle (`*ResourceBundle.properties`). В коде используются ID вида `{use.case.i18n.book}` вместо жёстких строк. Изменение языка пользователя → автоматическое изменение языка интерфейса.
- **Синтаксис (поиск)**: `CLASS Book '{use.case.i18n.book}';`

---

## Миграция

- **Описание**: файлы миграции описывают эволюцию схемы/данных. IDE автоматически генерирует миграционные строки при переименовании элементов и т.п. Позволяет безопасно развивать модель без ручного сопровождения SQL‑скриптов.

---

## Мини‑карта для ИИ

1. **Если видите `CLASS` → это тип объектов (таблица).**
2. **Если `= DATA` или выражение с `=` → это свойство (данные или формула).**
3. **Если `{ ... }` без `=` → действие (императивная логика, побочные эффекты).**
4. **Если `FORM` → описание UI/запроса/отчета над свойствами и объектами.**
5. **Если `SHOW` / `DIALOG` / `PRINT`  → открытие / печать формы.**
6. **Если `EXPORT` / `IMPORT`  → работа с внешними форматами для свойств / формы**
7. **Если `GROUP / PARTITION` → агрегаты по множествам (значения).**
8. **Если `GROUP AGGR` или `AGGR` → объектные агрегации.**
9. **Если `NEWSESSION / APPLY / CANCEL` → управление транзакцией / фиксацией.**
10. **Если `EXTEND` / `ABSTRACT` / `+=` / `+{` → точка расширения и полиморфные реализации.**
11. **Если `WHEN` → событие изменения данных (предметное событие).**
12. **Если `ON` → событие формы (интерактивного представления).**

