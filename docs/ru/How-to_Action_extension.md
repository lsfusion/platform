---
title: 'How-to: Расширение действий'
---

Для реализации полиморфизма можно использовать следующую схему:

### Пример 1

Создаем абстрактный класс `Shape` с абстрактным действием `whoAmI`:

```lsf
CLASS ABSTRACT Shape;
whoAmI  ABSTRACT ( Shape);
```

Создаем классы `Square` и `Circle`, который наследуется от `Shape`:

```lsf
CLASS Rectangle : Shape;
CLASS Circle : Shape;
```

Определяем реализацию `whoAmI` для созданных классов:

```lsf
whoAmI (Rectangle r) + {
    IF r IS Rectangle THEN {
        MESSAGE 'I am a rectangle';
    }
}
whoAmI (Circle c) + {
    IF c IS Circle THEN {
        MESSAGE 'I am a circle';
    }
}
```

При выполнении действия `whoAmI` будут вызваны все действия, которые были добавлены в качестве реализации. В описанном случае будет выдано соответствующее сообщение в зависимости от переданного аргумента.

### Пример 2

Предположим, что существует необходимость реализовать действие по копированию некоторого объекта (например, класса `Book`), семантика которого определяется в различных модулях. Это может быть реализовано следующим образом:

Объявляем класс `Book` и действия по его копированию:

```lsf
MODULE Book;

CLASS Book; // объявляем класс книга
// абстрактное действие, которое принимает на вход две книги и является "точкой входа", 
// в которую другие модули смогут добавлять реализацию
overCopy ABSTRACT (Book, Book); 
copy (Book book)  { // создаем действие по копированию книги
    NEW b = Book { // добавляем новую книгу
        overCopy(b, book);
    }
}
```

В зависимом модуле `MyBook` расширяем класс `Book` новыми свойствами и делаем, чтобы они также копировались:

```lsf
MODULE MyBook;

REQUIRE Book;

name = DATA STRING[100] (Book); // добавляем к товару некоторое свойство name
overCopy (Book s, Book d) + {
    name(d) <- name(s); // подключаем к действию копирования товара копирование созданного свойства
}
```
