---
title: 'Расширение свойств'
---

Техника [расширения](Extensions.md) [свойств](Properties.md) позволяет разработчику объявлять *абстрактное* свойство в одном [модуле](Modules.md), а определять его реализацию в других модулях. Эта техника по сути является "отложенным заданием" [оператора выбора](Selection_CASE_IF_MULTI_OVERRIDE_EXCLUSIVE.md), когда заголовок оператора определяется при объявлении свойства, а варианты выбора добавляются по мере добавления нового функционала ([классов](Classes.md), [статических объектов](Static_objects.md)) в систему. При этом варианты выбора (если он не взаимоисключающий) могут добавляться как в начало, так и в конец создаваемого абстрактного свойства.

Для абстрактных свойств необходимо задать предполагаемые классы параметров, тогда платформа автоматически проверит, что добавляемые реализации соответствуют этим классам. Также, при необходимости, можно проверить, что для всех потомков классов параметров задана хотя бы одна реализация (или ровно одна, если условия [взаимоисключающие](Selection_CASE_IF_MULTI_OVERRIDE_EXCLUSIVE.md)).

Расширение свойств позволяет:

-   Реализовывать концепцию полиморфизма свойств по аналогии с некоторыми объектно-ориентированными языками программирования.
-   Убирать зависимость между модулями, путем добавления определенных "точек входа" для изменения способа вычисления свойств.

### Полиморфная форма {#poly}

Также как и [для оператора выбора](Selection_CASE_IF_MULTI_OVERRIDE_EXCLUSIVE.md#poly), для абстрактного свойства существует *полиморфная форма*, когда условие выбора и соответствующий ему результат задаются одним свойством. Соответственно, как и в операторе выбора, условием может являться либо принадлежность [сигнатуре](Property_signature_CLASS.md) этого свойства, либо само это свойство.

### Взаимоисключаемость условий {#exclusive}

Как и [для оператора выбора](Selection_CASE_IF_MULTI_OVERRIDE_EXCLUSIVE.md#exclusive), для абстрактного свойства можно указать, что все его условия должны быть *взаимоисключающими*. Соответственно, если эта опция указана, а условия не являются взаимоисключающими, платформа выдаст соответствующую ошибку.

Стоит отметить, что такая проверка является не более чем подсказкой платформе (для лучшей оптимизации) и определенным самоконтролем со стороны разработчика. Однако, при этом использование такой проверки позволяет во многих случаях сделать код более прозрачным и читабельным (особенно в полиморфной форме абстрактного свойства).

### Язык

Ключевыми инструкциями, при помощи которых реализуется техника расширения свойств, являются [оператор `ABSTRACT`](ABSTRACT_operator.md) для объявления абстрактного свойства и [инструкция `+=`](+=_statement.md) для определения его реализации.

### Пример


```lsf
CLASS Invoice;
CLASS InvoiceDetail;
CLASS Range;

// В данном случае создается ABSTRACT MULTI EXCLUSIVE
rateChargeExchange(invoice) = ABSTRACT NUMERIC[14,6] (Invoice);             
// В данном случае создается ABSTRACT CASE OVERRIDE LAST, и если будут подходить несколько реализаций, 
// то вычислена будет первая из них
backgroundSku 'Цвет' (d) = ABSTRACT CASE FULL COLOR (InvoiceDetail); 
// Здесь же будет вычислена последняя из подходящих реализаций
overVAT = ABSTRACT VALUE OVERRIDE FIRST Range (InvoiceDetail);          
```

```lsf
CLASS ABSTRACT AClass;
CLASS BClass : AClass;
CLASS CClass : AClass;
CLASS DClass : AClass;

name(AClass a) = ABSTRACT BPSTRING[50] (AClass);
innerName(BClass b) = DATA BPSTRING[50] (BClass);
innerName(CClass c) = DATA BPSTRING[50] (CClass);
innerName(DClass d) = DATA BPSTRING[50] (DClass);

name(BClass b) = 'B' + innerName(b);
name(CClass c) = 'C' + innerName(c);

name[AClass](BClass b) += name(b);
// Здесь слева будет найден name[AClass], потому что поиск идет только среди абстрактных свойств,
// справа же будет найден name[CClass]
name(CClass c) += name(c); 
name(DClass d) += 'DClass' + innerName(d) IF d IS DClass;
```
