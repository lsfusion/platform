---
title: 'Простые ограничения'
---

В платформе на данный момент поддерживается четыре типа *простых ограничений* : *следствие*, *исключение*, *равенство*, *определенность*. Для всех простых ограничений поддерживается механизм *автоматического разрешения*, при включении которого, платформа вместо выдачи ошибки, сама приводит систему в целостное состояние.

| |Следствие|Исключение|Равенство|Определенность|
|---|---|---|---|---|
|Количество свойств|`2`|`2...N`|`2`|`1`|
|Описание|Если значение одного свойства (*посылка*) не `NULL`, то значение второго свойства (*следствие*) также должно быть не `NULL`|Только одно из значений заданных свойств должно быть не `NULL`|Если значение одного свойство не `NULL` и значение второго свойства не `NULL`, то они должны быть равны|Если все параметры свойства подходят по классам, то для них должно быть задано не `NULL` значение|
|Инструкция|[`=>`](=gt_statement.md)|**Пока не реализовано**|**Пока не реализовано**|Опция `NONULL` в задании свойств|
|Автоматическое разрешение|Поддерживаются два режима:<br/><br/>`LEFT` - если посылка изменяется на не `NULL`, то изменить\* следствие на не `NULL`<br/><br/>`RIGHT` - если следствие изменяется на `NULL`, то изменить посылку на `NULL`<br/>|Если одно из свойств изменяется на не `NULL`, изменить остальные на `NULL`|Если одно из свойств изменяется на не `NULL` значение, изменить второе на это же значение|`AGGR` - если значение свойства изменяется на `NULL`, удалить объекты соответствующие параметрам.<br/><br/>`DEFAULT` значение - если добавляются (доклассифицируются) объекты соответствующие классам параметров, изменить значение свойства для этих объектов на значение по умолчанию.|

\* Под изменением на `NULL` / не `NULL` понимается:

-   Для [первичного](Data_properties_DATA.md) свойства - [запись](Property_change_CHANGE.md) `NULL` или [значения по умолчанию](Built-in_classes.md#defaultvalue) для класса значения этого свойства.
-   Для [принадлежности](Classification_IS_AS.md) классу - удаление объекта / добавление объекта класса, для которого проверяется принадлежность.
-   Для [агрегирующего](Grouping_GROUP.md) оператора - (только если изменение на не `NULL`) добавление объекта базового класса (`System.Object`), изменение на не `NULL` условия агрегирующего оператора, запись во все значения группировок значений соответствующих параметров.

Так же как и для обычного [ограничения](Constraints.md), для каждого простого ограничения необходимо задать базовое [событие](Events.md), которое определяет когда будет проверяться заданное ограничение. 

Отметим что ограничение определенности является частным случаем следствия, у которого следствием является свойство, которое должно быть определено, а посылкой является его сигнатура (свойство полученное из него при помощи соответствующего [оператора](Property_signature_ISCLASS.md)).

Также существует неявный пятый вид простых ограничений - *уникальность*, но он совмещен с агрегирующим оператором (который получает это самое уникальное значение), поэтому здесь не рассматривается. Вместе со следствиями этот вид ограничений позволяет реализовывать механизм [агрегаций](Aggregations.md). 

### Примеры

```lsf
is(Sku s) = s IS Sku;
// для товара должны быть заданы штрих-код и наименование
is(Sku s) => barcode(s);
is(Sku s) => name(s);


CLASS Invoice;
CLASS InvoiceLine;
invoice = DATA Invoice (InvoiceLine);
is(InvoiceLine l) = l IS InvoiceLine;
// для строки документа должен быть задан документ, и при удалении документа, чтобы удалялись строки этого документа
is(InvoiceLine l) => invoice(l) RESOLVE RIGHT;
// равносильно объявлению document = DATA Invoice (InvoiceLine) NONULL DELETE;

// агрегация для f(a,b) создавать объект класса x, у которого свойство a(x) равняется a, а свойство b(x) равняется b
CLASS A;
CLASS B;
f = DATA BOOLEAN (A, B);

CLASS X;
a = DATA A(X);
b = DATA B(X);
is (X x) = x IS X;

f(a,b) => [ GROUP AGGR X x WHERE x IS X BY a(x), b(x)](a,b) RESOLVE LEFT;
is(X x) => f(a(x), b(x)) RESOLVE RIGHT;
```
