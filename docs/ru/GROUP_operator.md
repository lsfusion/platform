---
title: 'Оператор GROUP'
---

Оператор `GROUP` - создание [свойства](Properties.md), реализующего [группировку](Grouping_GROUP.md).

### Синтаксис 

    GROUP 
    type expr1, ..., exprN
    [ORDER [DESC] orderExpr1, ..., orderExprK]
    [WHERE whereExpr]
    [BY groupExpr1, ..., groupExprM]

### Описание

Оператор `GROUP` создает свойство, реализующее группировку. Тип группировки определяется видом [агрегирующей функции](Set_operations.md). Этот оператор отличается от других тем, что может неявно объявлять свои параметры в используемых выражениях (по аналогии с [инструкцией `=`](=_statement.md), когда параметры не заданы явно). При этом, важно понимать, что эти "неявно объявленные" параметры не являются параметрами создаваемого свойства (которые на самом деле определяются блоком `BY` и/или использованными верхними параметрами)

Блок `BY` описывает группировочные выражения. Каждое выражение соответствует параметру, создаваемого свойства. Как и в остальных операторах, в этом операторе разрешено использовать верхние параметры, причем использованные параметры также неявно являются группировками создаваемого свойства. Соответственно, при использовании оператора в [инструкции `=`](=_statement.md) и явном задании в этой инструкции параметров слева, выражения из блока `BY` отображаются только на неиспользованные параметры. При этом, если классы или количество этих параметров будет не соответствовать количеству / классам выражений `BY`, платформа выдаст ошибку. 


:::info
Если блок `BY` задан, этот оператор нельзя использовать внутри [выражений](Expression.md).
:::

Блок `ORDER` определяет порядок в котором будет вычисляться агрегирующая функция. Может указываться только для [некоммутативных](Set_operations.md) агрегирующих функций (`CONCAT`, `LAST`) и должен быть однозначно определяемым. Если в выражениях, задающих порядок, объявляется новый параметр (не использующийся в остальных блоках и в верхнем контексте), то при вычислении результирующего значения автоматически добавляется условие на не `NULL` всех этих выражений.

Блок `WHERE` определяет условие, при выполнении которого наборы объектов будут участвовать в операции группировки. Можно задавать только для агрегирующих функций `AGGR`, `NAGGR`, `LAST`.

:::info
Для `AGGR`, `NAGGR` использовать этот блок явно (а не, скажем, [оператор `IF`](IF_operator.md) в блоках `GROUP` и `BY`) имеет смысл, только с точки зрения возможности изменения создаваемого свойства на не `NULL` в некоторых автоматических механизмах платформы (например, в [автоматическом разрешении](Simple_constraints.md) простых ограничений).
:::

### Параметры

- `type`

    Тип агрегирующей функции. Может иметь следующие значения: `SUM`, `MAX`, `MIN`, `CONCAT`, `EQUAL`, `AGGR`, `NAGGR`, `LAST`. 

- `expr1, ..., exprN`

    Список выражений, значения которых идут на вход агрегирующей функции в качестве операндов. Количество выражений должно соотвествовать количеству операндов используемой функции. 

- `groupExpr1, ..., groupExprN`
  
    Список группировочных выражений (группировок). 

- `DESC`

    Ключевое слово. Указывает на обратный порядок просмотра наборов объектов. 

- `orderExpr1, ..., orderExprM`

    Список выражений, определяющих порядок, в котором будут просматриваться наборы объектов при вычислении агрегирующей функции. Для определения порядка сначала используется значение первого выражения, затем при равенстве используется значение второго и т.д. 

- `whereExpr`

    Фильтрующее выражение. В группировке будут участвовать только те наборы объектов, для которых значение фильтрующего выражения не равно `NULL`.

### Примеры

```lsf
CLASS Game;
CLASS Team;
hostGoals = DATA INTEGER (Game);
hostTeam = DATA Team (Game);
hostGoalsScored(team) = GROUP SUM hostGoals(Game game) BY hostTeam(game);

name = DATA STRING[100] (Country);
// получается свойство (STRING[100]) -> Country
countryName = GROUP AGGR Country country WHERE country IS Country BY name(country); 

CLASS Book;
CLASS Tag;
name = DATA STRING[100] (Tag);
in = DATA BOOLEAN (Book, Tag);

tags(Book b) = GROUP CONCAT name(Tag t) IF in(b, t), ', ' ORDER name(t), t;
```
