---
title: 'Таблицы'
---

Для хранения и вычисления значений [свойств](Properties.md) платформа **lsFusion** использует реляционную базу данных. Все [первичные свойства](Data_properties_DATA.md), а также все агрегированные [свойства](Properties.md), которые помечены как [материализованные](Materializations.md), хранятся в полях *таблиц* базы данных. Для каждой таблицы существует набор ключевых полей с именами `key0`, `key1`, ..., `keyN`, в которых хранятся идентификаторы объектов. Во всех остальных полях хранятся значения свойств таким образом, что в соответствующем поле каждого ряда  находится значение свойства для объектов с идентификаторами из ключевых полей. В качестве ключей таблицы могут также использоваться объекты [встроенных классов](Built-in_classes.md).

При создании таблицы необходимо указать список [классов](Classes.md) объектов, которые будут ключами в этой таблице.

### Определение таблиц свойств {#property}  

Для каждого свойства можно указать в какой таблице оно должно храниться. При этом количество ключей таблицы должно совпадать с количеством параметров свойства, а классы параметров должны подходить к классам ключей этой таблицы. Если для свойства таблица, в которой оно должно храниться, не задана явно, свойство автоматически будет помещено в "ближайшую" существующую в системе таблицу (то есть, количество ключей которой совпадает с количеством параметров свойства, и классы ключей которой ближе всего подходят к классам параметров). При этом, при необходимости, для таблицы можно при помощи специальной опции (`NODEFAULT`) указать, что при автоматическом определении таблиц свойств эту таблицу нужно игнорировать (то есть в такую таблицу свойство можно положить только явно при помощи соответствующей опции (`TABLE`)).

### Именование таблиц

Для каждой созданной таблицы в платформе создается соответствующая таблица в базе данных, имя которой, в зависимости от выбранной политики именования, определяется следующим образом:

| Политика именования                | Имя поля                      |
| ---------------------------------- | ----------------------------- |
| Полное с сигнатурой (по умолчанию) | `ПространствоИмен_ИмяТаблицы` |
| Полное без сигнатуры               | `ПространствоИмен_ИмяТаблицы` |
| Краткое                            | `ИмяТаблицы`                  |

Политика именования задается при помощи параметра запуска [`db.namingPolicy`](Launch_parameters.md#namingpolicy)

### Именование полей {#name}

Значения каждого свойства хранятся всегда ровно в одном поле, имя которого, в зависимости от выбранной политики именования, определяется следующим образом:

| Политика именования                | Имя поля                                                           |
| ---------------------------------- | ------------------------------------------------------------------ |
| Полное с сигнатурой (по умолчанию) | `ПространствоИмен_ИмяСвойства_ИмяКласса1_ИмяКласса2_..,ИмяКлассаN` |
| Полное без сигнатуры               | `ПространствоИмен_ИмяСвойства`                                     |
| Краткое                            | `ИмяСвойства`                                                      |

При необходимости, для каждого свойства разработчик может явно указать имя поля, в котором будет храниться это свойство. Кроме того существует возможность создать свою политику именования полей свойств, если вышеперечисленные по каким-то причинам не подходят.


:::info
Использование слишком краткой политики именования свойств (если количество материализованных свойств достаточно большое) может значительно усложнить [именование](Naming.md) этих свойств (так, чтобы оно было уникальным), или, соответственно, приводить к слишком частой необходимости явно именовать поля, в которых будут храниться эти свойства.
:::

Политика именования задается при помощи параметра запуска [`db.namingPolicy`](Launch_parameters.md#namingpolicy).

### Таблицы по умолчанию

Если для свойства система не может определить таблицу, в которую должно быть помещено это свойство, то автоматически создается таблица с именем равным `auto_<идентификатор класса 1 в сигнатуре свойства>_<идентификатор класса 2 в сигнатуре свойства>_...<идентификатор класса n в сигнатуре свойства>`. Например, для свойства с аргументами классов `DATE`, `Item.Item`, `Country.Country`, `INTEGER` будет создана таблица `auto_DATE_Item_Item_Country_Country_INTEGER`. Впрочем, ситуаций когда используется таблица по умолчанию рекомендуется не допускать, а задавать таблицы в которых будут храниться свойства явно.

В платформе также существует возможность создать свою политику именования таблиц по умолчанию, если базовая политика по каким-то причинам не подходит.

### Индексы по умолчанию

По умолчанию, для каждой таблицы строится уникальный [индекс](Indexes.md) по ее ключевым полям `key0`, `key1`, ..., `keyN` с именем `pk_<идентификатор таблицы>`, где `N` - количество ключевых полей в таблице минус `1`. Также автоматически добавляются индексы по ключевым полям `keyK`, ..., `keyN` с именами `<идентификатор таблицы>_keyK_..._keyN_idx`, для всех `K` от `1` до `N`.

### Полные таблицы {#full}

Будем говорить, что таблица *полная*, если для каждого своего ключа она содержит все существующие в системе объекты класса этого ключа. В общем случае, полнота таблицы задается явно при помощи специальной опции (`FULL`) и реализуется через неявное создание материализованного свойства [классификации](Classification_IS_AS.md)(-ам) (будем называть такое свойство свойством *полноты*). Впрочем, в некоторых случаях, платформа может не создавать это свойство, если определит, что в таблице и так есть свойства, которые гарантируют наличие в ней всех необходимых объектов (например, свойство принадлежности классу).

По умолчанию, свойство полноты получает имя `_FULL_ИмяТаблицы`. При этом, при определении имени поля этого свойства используется краткая политика именования (так как в таблице такое поле может быть ровно одно и нет смысла создавать настолько громоздкие имена).

Стоит отметить, что полнота таблицы важна только с точки зрения оптимизации выполнения (к примеру, сервер знает, что в некоторой таблице есть все объекты нужного класса, и вместо `LEFT JOIN` использует `INNER JOIN`, что может быть критичным в некоторых случаях), и, как и сам механизм таблиц, на логику работы системы никак не влияет.

### Хранение принадлежности классу

Принадлежность классу является такой же первичной информацией, как и [первичные](Data_properties_DATA.md) свойства. Соответственно, как и первичные свойства, эта принадлежность хранится в поле некоторой таблицы. В свою очередь, эта таблица определяется по аналогии с тем, как определяется таблица для остальных материализованных свойств (предполагая, что принадлежность классу это свойство с одним параметром этого класса), с той лишь разницей, что предварительно рассматриваются только полные таблицы (то есть они своего рода имеют приоритет), и, только если ни одна полная таблица не найдена, рассматриваются остальные (неполные) таблицы.

Если некоторая таблица для каждого своего ключа хранит принадлежность классу всех потомков класса этого ключа, она, во-первых, автоматически помечается как полная (даже если это не было указано явно), во вторых для нее не создается свойство полноты (предполагается, что роль этого свойства выполняет само свойство принадлежности классу).

По умолчанию, свойство принадлежности классу получает имя `_CLASS_ИмяТаблицы`. При этом, при определении имени поля этого свойства используется краткая политика именования (так как в таблице такое поле может быть ровно одно и нет смысла создавать слишком громоздкие имена).

### Язык

Для создания таблиц необходимо использовать [инструкцию `TABLE`](TABLE_statement.md). Для определения таблицы, в которую необходимо положить свойство, используется [опцию `TABLE`](Property_options.md) в опциях свойств.

### Примеры

```lsf
TABLE book (Book);

in = DATA BOOLEAN (Sku, Stock);
TABLE skuStock (Sku, Stock); // в ней будет храниться свойство in

price = DATA NUMERIC[10,2] (Sku, DATE);
TABLE skuDate (Sku, DATE); // в ней будет храниться свойство Sku

TABLE sku (Sku) FULL;
```
