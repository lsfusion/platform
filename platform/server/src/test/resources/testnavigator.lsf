MODULE testNavigator;

REQUIRE System;

/////////// GROUP STATEMENT ////////////

// Syntax:
// GROUP name ['caption'] [: parentGroup];
GROUP base 'Основная группа' : base;
GROUP simpleGroup;
GROUP sampleGroup : System.base; // явная квалификация имен

/////////// CLASS STATEMENT ////////////

// Non-static class
// Syntax:
// CLASS [ABSTRACT] name ['caption'] [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN]];
CLASS ABSTRACT namedClass : named;
CLASS emptyClass;
CLASS article 'Товар' : namedClass;
CLASS store 'Склад' : namedClass;
CLASS document 'Документ' : transaction;
CLASS incomeDocument 'Приход' : document, emptyClass;
CLASS outcomeDocument 'Расход' : document, emptyClass;

// Static class
// Syntax:
// CLASS STATIC name ['caption'] {
//      instanceName1 ['instanceCaption1']
//      [, instanceName2 ['instanceCaption2']]
//      ...
//      [, instanceNameN ['instanceCaptionN']]
// }
// [: nonStaticBaseClass1 [, nonStaticBaseClass2, ..., nonStaticBaseClassN];]
CLASS STATIC storeSize 'Размер склада'
{
    huge 'огромный',
    big 'большой',
    medium 'средний',
    small 'маленький'
}


//////////// PROPERTY STATEMENT///////////
// Common syntax:
// name ['caption'] [(namedParam1, ..., namedParamN)] = propertyExpression [IN group] [PERSISTENT];
// Если именованные параметры не указываются, то они выводятся из propertyExpression

// Data property
// Expression syntax:
// DATA returnClass ( [paramClass1, ..., paramClassN] )
// Built-in types: INTEGER, LONG, DOUBLE, BOOLEAN, DATE, STRING, ISTRING
store = DATA store (document) IN base;
quantity = DATA DOUBLE (document, article) IN base;
storeSize = DATA storeSize (store) IN base;

// Join property
// Expression syntax:
// (name | '[' propertyDefinition ']') (param1, ..., paramN)
storeName 'Склад' (document) = name(store(document)) IN base;
storeSizeName = name(storeSize(store)) IN base; // можем не указывать именованные параметры слева от '=', но все равно пользоваться ими
objectIsStore = [IS store](object);             // аналог: object IS store

// IS, AS
// Expression syntax:
// propertyExpression (AS | IS) className
// IS - is(), AS - object()
isIncomeDocument(document) = document IS incomeDocument;


// AND, IF (идентичны по действию)
// Expression syntax:
// propertyExpression (AND | IF) [NOT] propertyExpression
inQuantity(document, article) = quantity(document, article) IF isIncomeDocument(document);
outQuantity(document, article) = quantity($1, $2) IF $1 IS outcomeDocument;  // указание номеров параметров вместо имен

// Group property
// Expression syntax:
// GROUP (SUM | MAX) propertyExpression BY propertyExpression1, ..., propertyExpressionN
incomeQuantity(store, article) = GROUP SUM inQuantity(document, article) BY store(document), article;
outcomeQuantity(store, article) = GROUP SUM outQuantity(doc, art) BY store(doc), art;

incomeQuantity2(store, article) = GROUP SUM quantity(document, article) IF document IS incomeDocument BY store(document), article;
outcomeQuantity2(store, article) = GROUP SUM quantity(doc, art) IF doc IS outcomeDocument BY store(doc), art;

// Union property
// Expression syntax:
// UNION (SUM | MAX | OVERRIDE | XOR | EXCLUSIVE) propertyExpression1, ..., propertyExpressionN
testUnion(store, article) = UNION SUM incomeQuantity(store, article), outcomeQuantity(store, article);

// Partition property
// Expression syntax:
// PARTITION (SUM | PREV) propertyExpression
// [BY propertyExpressionM1, ..., propertyExpressionMN]
// [ORDER [DESC] propertyExpressionL1, ..., propertyExpressionLK]
// [WINDOW EXCEPTLAST]
testPartition(store, article) = PARTITION SUM incomeQuantity(store, article) BY store ORDER DESC name(article);

// Formula property
// Expression syntax:
// FORMULA primitiveType 'formula text $1 + $2'
sum12 = FORMULA DOUBLE '($1)+($2)*2';
testFormula(store, article) = sum12(incomeQuantity(store, article), outcomeQuantity(store, article));

// Computational expressions
// Priority:
// AND  IF
// ==  !=
// <  >  <=  >=
// +  -
// *  /
// - (unary)
//
// Instances: 5, 6.35, TRUE, 'some string', staticClass.object
balanceQuantity(store, article) = incomeQuantity(store, article) - outcomeQuantity(store, article);

foo(store, article) = 5 * incomeQuantity($1, $2) - outcomeQuantity($1, $2);
foo2(store, article) = - outcomeQuantity(store, article) + 5 * incomeQuantity(store, article);
bar = incomeQuantity(store, article) * 5 - 3 - 4 + outcomeQuantity(store, article);
bar2(store, article) = 3.5 * incomeQuantity($1, $2) - (-5 + outcomeQuantity($1, $2));
foobar(store, article) = [x*x + y](foo(store, article), bar(store, article));   // lambda-like syntax
baz(store, article) = bar(store, article) > bar2(store, article) IN base;
baz2 = foo(s, a) >= 15 == foo2(s, a) >= 15;

storeIsHuge(store) = storeSize(store) == storeSize.huge;                        // static class instance
storeIsHuge2(store) = (storeSize(store) == storeSize.huge) == TRUE;

documentBalance(document, article) = balanceQuantity(store(document), article);

///////////////CONSTRAINT STATEMENT//////////////

// Syntax:
// CONSTRAINT [CHECKED] propertyExpression MSG 'message';
CONSTRAINT CHECKED foo(store, article) > 1000 MSG 'ошибка: >1000';


////////////////FOLLOWS STATEMENT////////////////
// Syntax:
// propertyName(param1, ..., paramN) =>
//      propertyExpression1 [RESOLVE (TRUE | FALSE | ALL | NOTHING)],
//      ...
//      propertyExpressionK [RESOLVE (TRUE | FALSE | ALL | NOTHING)];
foo(store, article) => foo2(store, article) RESOLVE NOTHING, bar2(store, article);


//////////////WRITEONCHANGE STATEMENT////////////
// Syntax:
// propertyName(param1, ..., paramN) <- [OLD] valueProperty(param1, ..., paramK) ON (ASSIGN | CHANGE) changeProperty(param1, ..., paramL);


//////////////// FORM STATEMENT /////////////////

FORM storeArticle 'По складам'
OBJECTS s=store, a=article
PROPERTIES SELECTION(s), name(s), OBJVALUE(a), name(a)
PROPERTIES(s, a) incomeQuantity, incomeQuantity2, outcomeQuantity, outcomeQuantity2
PROPERTIES(s) storeSizeName, storeIsHuge, storeIsHuge2
PROPERTIES(s, a) foo, foo2, bar, foobar, bar2, baz, baz2, balanceQuantity, testUnion, testPartition, testFormula;

